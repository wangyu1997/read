
---
## OS支持特性

在OS设计中，需要在不同任务间切换，这一般被称作上下文切换，其通常在PendSV异常处理中执行，该异常可由SysTick异常触发。在上下文切换操作中需要：

    将寄存器的当前状态保存到当前栈中
    保存当前PSP数值
    将PSP设置为下一个任务的上一次SP数值
    恢复下一个任务的上一次的数值
    利用异常返回切换任务

### SVC异常：
SVC异常类型为11，且优先级可编程。  
在许多系统中，SVC机制可用于实现应用任务访问系统资源的API。  
对于需要高可靠性的系统，应用任务可以运行在非特权访问等级，而且有些硬件资源可被设置为只支持特权访问(利用MPU)，应用任务只能通过OS的服务访问这些受保护的硬件资源。由于由于任务无法获得关键硬件的访问权限，，嵌入式系统会更加 健壮和安全。

C编译环境，将SVC处理分为两个部分：

    第一部分提取栈帧的起始地址，并将其作为输入参数传递给第二部分。该处理要有汇编实现，这是因为需要检查LR的数值(EXC_RETURN)，而其无法用C实现。
    第二部分从栈帧中提取压栈的PC数值，然后从程序代码中得到 SVC 编号。它还可以选择提取出压栈的寄存器数值等其他信息。

传递栈帧地址的好处在于，C处理可以提取出栈帧中的任何信息，包括压栈寄存器在内。若要将参数传递给SVC服务并获得SVC服务的返回值。由于异常处理实际上可以为普通C函数，若调用了SVC服务，且同时产生了更高优先级的中断，则更高优先级的ISR会首先执行，但这样会修改R0~R3以及R12等的数值。为了确保SVC处理能够得到正确的参数，需要从栈帧中获取参数值。若SVC服务要返回一个数值，则需要利用栈帧进行数值返回。否则，存储在寄存器组中的返回值会在异常返回过程中被出栈操作覆盖。

### PendSV异常：
PendSV异常编号为14，且具有可编程的优先级。  
可以写入中断控制和状态寄存器(ICSR)设置挂起位以触发PendSV异常。  
他的挂起状态可在更高优先级异常处理内设置，且会在高优先级处理完成后执行。  

OS内核的执行可由以下条件触发：

    应用任务中 SVC 指令的执行。例如，当应用任务由于等待一些数据或事件被耽搁时，它可以调用系统服务以便切换到下一个任务。
    周期性的SysTick异常。

利用PendSV进行上下文切换事件流程：

    A任务调用 SVC 进行任务切换(例如，等待一些工作完成)。
    OS收到请求，准备进行上下文切换，且挂起PendSV异常。
    当CPU退出 SVC 时，会立即进入PendSV且进行上下文切换。
    当PendSV完成并返回线程等级时，OS会执行 B 任务。
    中断产生且进入中断处理。
    在运行中断处理程序时，SYSTICK异常(用于OS节拍)会产生。
    OS执行重要操作，然后挂起PendSV异常并准备进行上下文切换。
    当SYSTICK异常退出时，会返回到中断服务程序。
    当中断服务程序结束后，PendSV开始执行实际的上下文切换操作。
    当PendSV完成后，程序返回到线程等级，这次它会回到任务A并继续执行。

(不存在OS环境)中断服务程序可能需要一些处理时间，要处理的部分可能会需要高优先级，不过如若整个ISR都是在高优先级中执行的，其他的中断服务可能在很长时间内都无法执行。可以将中断服务处理划分为两个部分：

    第一部分对时间要求比较高，需要快速执行，且优先级较高。它位于普通的ISR内，在ISR结束时，设置PendSV的挂起状态。
    第二部分包括中断服务所需的剩余的处理工作，它位于PendSV处理内且具有较低的异常优先级。

### 排他访问和嵌入式OS

多任务系统，多个任务共享有限资源的情况。  
处理器支持一种名为排他访问的特性。信号量变量通过排他加载和排他存储进行读写。若在存储期间无法保证访问为排他的，排他存储会失败，而写操作则不会产生。处理器接下来应该重试排他访问流程。  
处理器内部存在一个名为本地监控的小的硬件单元。一般情况下，它处于开放访问状态。在执行完排他加载指令后，它就会切换到排他访问状态。只有在本地监控处于排他访问状态且总线系统未响应排他失败时排他存储才能执行。  
若满足以下任何一个条件，排他写(如STREX)会失败：

    执行了CLREX指令，本地监控切换到开放访问状态。
    产生了上下文切换(如中断)。
    前面没有执行LDREX。
    外部硬件通过总线接口上的边带信号向处理器返回排他访问状态。

若排他存储得到一个失败状态，则存储器中不会产生实际的写操作，这是因为它会被处理器内核或外部硬件阻止。


---

## 3级流水线

![image](http://my.csdn.net/uploads/201204/18/1334679369_7684.jpg)

    (1)取指从存储器装载一条指令
    (2)译码识别将要被执行的指令
    (3)执行处理指令并将结果写回寄存器

ARM正在执行第1条指令的同时对第2条指令进行译码，并将第3条指令从存储器中取出。

所以，流水线只有在取第4条指令时，第1条指令才算完成执行。

下图生动形象的说明了3级流水线的处理机制：
![image](http://my.csdn.net/uploads/201204/18/1334680233_9073.jpg)

无论处理器处于何种状态，程序计数器R15(PC)总是指向“正在取指”的指令，而不是指向“正在执行”的指令或者正在“译码”的指令。

一般会习惯性的将正在执行的指令作为参考点，即当前第1条指令。

所以，PC总是指向第3条指令，

或者说PC总是指向当前正在执行的指令地址再加2条指令的地址。

流水线只有被指令填满时才能发挥最大效能，即每时钟周期完成一条指令的执行（仅单周期指令）。

如果程序发生跳转，流水线会被清空，这将需要几个时钟才能使流水线被再次填满。因此，尽量地少使用跳转指令可以提高程序的执行效率。

---
---
---

## AES加密和解密

算法由多个轮构成，其中每一轮分为SubBytes、ShiftRows、MixColumns和AddRoundKey共4个步骤。输入分组128比特，16字节。

**SubBytes** 以每个字节的值(0~255的任意值)为索引，从一张拥有256个值的替换表中查找出对应值的处理。  
**ShiftRows** 将以4字节为单位的行(row)按照一定的规则向左平移，且每一行平移的字节数是不同的。  
**MixColumns** 对一个4字节的值进行比特运算，将其变为另外一个4字节值。  
**AddRoundKey** 将MixColumns的输出与轮密钥进行XOR。  
重复进行10~14轮计算。  
解密按照相反的顺序进行。

## RSA

**RSA的密文是对明文的E次方求mod N的结果** E和N的组合就是公钥  
**RSA的明文是对密文的D次方求mod N的结果** D和N的组合就是私钥

### 生成密钥对：
求N：  
用伪随机数生成器求p和q，p和q都是质数  
**N = p * q**

求L(L是仅在生成密钥对的过程中使用的数)：  
L是p-1和q-1的最小公倍数  
**L = lcm(p-1, q-1)**  

求E:  
E是一个比1大、比L小的数。E和L的最大公约数必须为1。  
**1 < E < L**  
**gcd(E, L) = 1**  

求D：  
**1 < D < L**  
**E * D mod L = 1**  

## 单向散列函数
**单向散列函数** 有一个输入和一个输出，其中输入成为消息，输出成为散列值。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。

性质：

    根据任意长度的消息计算出固定长度的散列值
    能够快速计算出散列值
    消息不同散列值也不同
    具备单向性

## SHA-3 (Keccak)
海绵结构：输入的数据在进行填充后，要经过吸收阶段和挤出阶段，最终生成输出的散列值。  
吸收过程如下：

    将经过填充的输入消息按照每r个比特为一组分割成若干个输入分组
    首先，将“内部状态的r个比特”与“输入分组1”进行XOR，将其结果作为“函数f的输入值”
    然后，将“函数f的输出值r个比特”与“输入分组2”进行XOR，将其结果再次作为“函数f的输入值”
    反复执行上述步骤，直到到达最后一个输入分组
    待所有输入分组处理完成后，结束吸收阶段，进入挤出阶段

挤出阶段如下：

    首先，将“函数f的输出值中的r个比特”保存为“输出分组1”，并将整个输出值(r + c个比特)再次输入到函数f中
    然后，将“函数F的输出值中的r个比特”保存为“输出分组2”，并将整个输出值(r + c个比特)再次输入到函数f中
    反复执行上述步骤，知道获得所需长度的输出数据

Keccak的内部状态：5 * 5 * z  

函数Keccak-f[b]：  

    步骤θ  
    步骤ρ  
    步骤π
    步骤X
    步骤l


































































































