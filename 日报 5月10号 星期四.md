
## 各个 Cortex-M 处理器间 NVIC 差异一览：

   |                |   Cortex-M0   |   Cortex-M0+   |   Cortex-M1   |   Cortex-M3   |   Cortex-M4
   :---:            |     :---:     |     :---:      |     :---:     |     :---:     |     :---:     
   中断数量         |   1~32        |   1~32         |   1、8、16、32|   1~240       |   1~240
   NMI              |   Y           |   Y            |   Y           |   Y           |   Y
   优先级宽度       |   2           |   2            |   2           |   3~8         |   3~8
   寄存器访问       |   字          |   字           |   字          | 字、半字、字节|   字、半字、字节
   PRIMASK          |   Y           |   Y            |   Y           |   Y           |   Y
   FAULTMASK        |   N           |   N            |   N           |   Y           |   Y
   BASEPRI          |   N           |   N            |   N           |   Y           |   Y
   向量表偏移寄存器 |   N           |   Y(可选)      |   N           |   Y           |   Y
   动态修改优先级   |   N           |   N            |   N           |   Y           |   Y
   中断活跃状态     |   N           |   N            |   N           |   Y           |   Y
   错误处理         |   硬件错误    |   硬件错误     |   硬件错误    |硬件错误+3个其他错误异常|硬件错误+3个其他错误异常
   调试监控异常     |   N           |   N            |   N           |   Y           |   Y


---


## 异常处理

### C实现的异常处理

**调用者保存寄存器：** R0~R3、R12、LR、PSR。若在函数调用后还需要使用这些寄存器数值，在调用前，由调用子程序的程序代码将寄存器内容保存到内存中(如栈)。

**被调用者保存寄存器：** R4~R11。被调用的子程序后函数需要确保这些寄存器在函数结束时不会发生变化。在函数退出前将它们恢复为初始值。

### 栈帧

**栈帧：** 在异常入口处被压入栈空间的数据块。

**双字栈对齐：** 栈指针的数值被要求在函数入口和出口处应该是双字对齐的。若在中断产生时栈帧未对齐到双字地址上，处理器会自动插入一个字。并且压栈的xPSR的第9位会被置为1，否则第9位为0。

### EXC_RETURN

EXC_RETURN 的位域

   位   |        描述         |   数值
  :---: |        :---:        |   :---:
  31:28 |   EXC_RETURN 指示   |   0xF
  27:5  |        保留(全为1)  |   0xEFFFFF(23位都是1)
  4     |        栈帧类型     |   1(8字)或0(26字)。当浮点单元不可用时总是为1，在进入异常处理时，其会被置为CONTROL寄存器的FPCA位
  3     |        返回模式     |   1(返回线程)或0(返回处理)
  2     |        返回栈       |   1(返回线程栈)或0(返回主栈)
  1     |        保留         |   0
  0     |        保留         |   1

EXC_RETURN 的合法值

   |                                | 浮点单元在中断前使用(FPCA=1) | 浮点单元未在中断前使用(FPCA=0)
   :---:                            | :---:                        | :---:
   返回处理模式(总是使用主栈)       | 0xFFFFFFE1                   | 0xFFFFFFF1
   返回线程模式并在返回后使用主栈   | 0xFFFFFFE9                   | 0xFFFFFFF9 
   返回处理模式并在返回后使用进程栈 | 0xFFFFFFED                   | 0xFFFFFFFD


### 异常进入和压栈

压栈操作中用的可以为主栈或进程栈。  
若处理器运行在线程模式且使用MSP，则压栈操作执行时使用MSP。  
若处理器运行在线程模式且使用PSP，则压栈操作执行时使用PSP。在进入处理模式后，处理器必须使用MSP，所有嵌套中断的压栈操作执行时都使用主栈MSP。

### 异常返回和出栈

在异常处理结束时，异常入口处生成的 EXC_RETURN 数值的第2位用于确定提取栈帧时所用的栈指针。  
若第2位为0，处理器知道之前压栈时使用的是主栈，若第二位为1，处理器知道压栈时使用的是进程栈。
在每次出栈操作结束时，处理器会检查出栈 xPSR 数值的第9位，并且若压栈时插入了额外空间则会将其去除。

### 出栈操作

```
graph TD
    A((执行异常返回)) -->|EXC_RETURN 2=0| B[出栈时使用MSP]
    A -->|EXC_RETURN 2=1| C[出栈时使用PSP]
    B --> |出栈的xPSR 9=0| D[MSP调整未增加空位]
    B --> |出栈的xPSR 9=1| E[MSP调整使用空位]
    D --> F[选择了MSP CONTROL 1 = 0]
    E --> F[选择了MSP CONTROL 1 = 0]
    C --> |出栈的xPSR 9=0| G[MSP调整未增加空位]
    C --> |出栈的xPSR 9=1| H[MSP调整使用空位]
    G --> I[选择了PSP CONTROL 1 = 0]
    H --> I[选择了PSP CONTROL 1 = 0]
    F --> J((继续程序执行))
    I --> J
    
```

### 中断等待和异常处理优化

**中断等待：** 从中断请求开始到中断处理开始执行间的时间。  
**多周期指令执行时的中断：** 在处理器执行多周期指令时产生了中断请求，该指令可能会被丢弃且在中断处理结束后重新执行。若在中断产生时 LDM/STM/PUSH/POP 中的一个指令正在执行，当前的存储器访问会结束，且下一个寄存器编号会被存放在压栈的xPSR中(中断继续指令[ICI]位)。异常处理结束后，多加载/多存储/压栈/出栈会从传输停止的位置继续执行。  
**末尾连锁：** 若某个异常产生时处理器正在处理另一个具有相同或更高优先级的异常，该异常会挂起。处理器执行完当前异常后，继续执行挂起的异常请求。处理器不会从栈中回复寄存器(出栈)然后再将它们存入栈中(压栈)，而是跳过出栈和压栈过程并会尽快进入挂起异常的异常处理。两个异常处理间隔时间会降低很多，并带来了更佳的能耗效率。  
**延迟到达：** 当异常产生时，处理器会接受异常请求并开始压栈操作。若在压栈操作期间产生了另外一个更高优先级的异常，则更高优先级的后到异常会首先得到服务。  
**出栈抢占：** 若某个异常请求在另一个刚完成的异常处理出栈期间产生，处理器会舍弃出栈操作且开始取向量以及下一个异常服务的指令。


---

## 低功耗和系统控制特性

**低功耗系统需求：** 动态电流、休眠模式电流、能耗效率、唤醒等待。

休眠模式：

    掉电(将处于掉电模式下的系统唤醒的唯一方法为系统复位)
    具有状态保持功率门(SRPG)的深度休眠(处于状态保持中的数字回路掉电)
    深度休眠(所有的时钟信号停止)
    休眠模式(多数时钟信号停止，处理器只有一小部分在运行)
    活跃

### 进入休眠模式

    WFI    void _WFI(void);    等待中断    进入休眠模式。处理器可由中断请求、调试请求或复位唤醒
    WFE    void _WFE(void);    等待事件    条件进入休眠模式。若内部事件寄存器为0，则处理器会进入休眠模式。否则内部事件寄存器会被清除，且处理器会继续执行。处理器可由中断请求、事件输入、调试请求或复位唤醒

### 唤醒条件
中断可以将处理器从休眠模式唤醒。  
若利用WFI或退出时休眠进入休眠模式，需要使能中断请求，且中断优先级要大于当前等级。  
若利用WFE进入休眠模式，当中断请求产生且设置了挂起条件后，一个名为 SEVONPEND 的特性可用于唤醒事件的产生，而不管中断是否使能或优先级是否大于当前等级。

### 退出时休眠特性
使能后，Cortex-M处理器会在退出异常并返回到线程模式时自动进入休眠(此时没有中断请求等待处理)。

### 唤醒中断控制器(WIC)
WIC可以在没有时钟信号的情况下运行。当产生中断请求时，WIC检测到该请求并通知PMU恢复时钟，然后处理器被唤醒并处理中断请求。
SRPG状态保持功率门在当系统处于深度休眠模式时，可以将普通部分的供电关掉，只保留状态保持单元的。SRPG掉电状态无法检测到中断请求，当应用SRPG技术后，也就需要WIC了。


降低动态功耗：

    选择合适的微控制器
    运行在合适的时钟频率
    选择合适的时钟源
    关闭未使用的时钟信号
    利用时钟系统特性
    供电设计
    在SRAM中运行程序
    使用正确的I/O端口配置

降低活跃周期：使用休眠模式、降低运行时间。

减小休眠模式电流：

    使用合适的休眠模式
    使用电源控制特性
    休眠期间关掉Flash存储器

## SysTick 定时器

SysTick 寄存器一览：
   地址    |    CMSIS-Core符号    |    寄存器
   :---:   |    :---:             |    :---:
0xE000E010 |    SysTick->CTRL     |    SysTick 控制和状态寄存器
0xE000E014 |    SysTick->LOAD     |    SysTick 重装载值寄存器
0xE000E018 |    SysTick->VAL      |    SysTick 当前值寄存器
0xE000E01C |    SysTick->CALIB    |    SysTick 校准值寄存器

### 使用 SysTick 定时器

**uint32_t SysTick_Config(uint32_t ticks);**  
将SysTick中断间隔设置为ticks，使能计数器使用处理器时钟，然后设置SysTick异常为最低优先级。

SysTick定时器中的寄存器只能在特权状态下访问。  
参考时钟在一些微控制器设计中可能会不存在。  
若应用中存在嵌入式OS，SysTick定时器会被OS使用，因此就不能再被应用任务使用了。  
当处理器在调试期间暂停时，SysTick定时器会停止计数。  
根据微控制器的实际设计，SysTick定时器可能会在某些休眠模式中停止计数。

### 自复位

SYSRESETREQ位(第2位)可以产生到微控制器系统复位控制逻辑的系统复位请求。  
VECTRESET控制位(第0位)，主要是供调试器使用，该位写1后，会复位处理器中除调试逻辑外的所有部分，不包括外设。

### 配置控制寄存器

**CCR：** 系统控制块(SCB)中的一个名为配置控制寄存器(CCR)的寄存器，可以调整处理器的某些行为以及控制高级特性。  
**STKALIGN位：** 当STKALIGN位为1时，会强制将栈帧放到双字对齐的存储器位置处。 SCB->CCR |= SCB_CCR_STKALIGN_Msk;  
**BFHFNMIGN位：** 当设置该位时，优先级为-1(如HardFault)或-2(如NMI)的异常处理会忽略加载和存储指令引起的数据总线错误。它还可用于配置异常处理(如总线错误、使用错误或存储器管理错误)在FAULTMASK置位时执行的情形。  
**UNALIGN_TRP位：** 若UNALIGN_TRP位为1，则当产生非对齐传输时会触发使用错误异常，为0，非对齐传输只支持单加载和存储指令，其中包括LDR、LDRT、LDRH、LDRSH、LDRHT、LDRSHT、STR、STRH、STRT和STRHT。  
**USERSETMPEND位：** 置位后，非特权任务可以触发系统异常外的任意软件中断。








































